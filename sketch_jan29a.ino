/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/b9727382-8934-469a-9d6f-e4ce069bd6e8 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String user_message;
  float critical_power;
  float critical_voltage;
  float current_measurement_output;
  float power_measurement_output;
  float voltage_measurement_output;
  bool alerts_on;
  bool operational_state;
  bool send_push_notification;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <Wire.h>
#include <Adafruit_INA219.h>

#define ALARM_PIN 2
#define WARNING_PIN 3
#define OK_PIN 4
#define VOLTAGE_PIN = A0

Adafruit_INA219 ina219;

// Define the voltage divider resistor values
const float R1 = 30000.0; // 30k resistor
const float R2 = 7500.0;  // 7.5k resistor

//define parameters
int voltage_sensorValue=0;
float pin_voltage_V =0.0;

float voltage_V = 0.0;
float current_mA =0.0;

const int windowSize = 5;
float current_values[windowSize] = {0.0};
float voltage_values[windowSize] = {0.0};
int valuesIndex =0;
float current_sum = 0.0;
float voltage_sum = 0.0;

//counting variable
int i;
int j;

//Development: User messages:
  // TODO: This should be a text file
  const String RES_dropoff_warning_message = "WARNING: RES is not providing sufficient power.";
  const String RES_dropoff_alert_message = "WARNING: RES is below critical threshold.";
  const String switchover_RES_to_BES_message = "Switching Over to BES.";
  const String switchover_BES_to_RES_message = "Switching Over to RES.";
  const String all_systems_ok_message = "All Systems Operational";
  const String startup_message = "Successful Startup!";
  const String alerts_on_message = "Alerts switched on.";
  const String alerts_off_message = "Alerts switched off.";
  
//Counting variable for alarm function
int exceed = 0;
int exceed_threshold = 5;

//alarm configuration
int alarm_rings = 3;
int alarm_on_time = 50;
int alarm_off_time = 100;

//safety factor (1.1 = 10% safety factor)
float safety_factor = 1.1;

void setup() {
  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  
    // put your setup code here, to run once:
  Serial.begin(115200);
  while (!Serial) {
      // will pause Zero, Leonardo, etc until serial console opens
      delay(1);
  }

Serial.println("Hello!");
  
  // Initialize the INA219.
  // By default the initialization will use the largest range (32V, 2A).  However
  // you can call a setCalibration function to change this range (see comments).
  if (! ina219.begin()) {
    Serial.println("Failed to find INA219 chip");
    while (1) { delay(10); }
  }
  // To use a slightly lower 32V, 1A range (higher precision on amps):
  //ina219.setCalibration_32V_1A();
  // Or to use a lower 16V, 400mA range (higher precision on volts and amps):
  //ina219.setCalibration_16V_400mA();

  Serial.println("Measuring voltage and current with INA219 ...");
  
  //define pinmodes for alarm
  pinMode(ALARM_PIN, OUTPUT);
  pinMode(WARNING_PIN, OUTPUT);
  pinMode(OK_PIN, OUTPUT);
  
  //initialise cloud variables
  critical_voltage =0.0;
  critical_power =0.0;
}

void loop() {
  ArduinoCloud.update();

//----------------- data aquisition ----------------------------------

  current_mA = ina219.getCurrent_mA();

//take a voltage reading
voltage_sensorValue = analogRead(A0); // Read the voltage at pin A0
pin_voltage_V = voltage_sensorValue * (5.10 / 1023.0); // Convert the sensor value to voltage

// Calculate the actual voltage using the voltage divider formula
voltage_V = pin_voltage_V * (R1 + R2) / R2;

//1 decimal place
voltage_V = round(10*voltage_V)/10;

  // Update the moving average array
  current_values[valuesIndex] = current_mA;
  voltage_values[valuesIndex] = voltage_V;
  valuesIndex = (valuesIndex + 1) % windowSize;

  // Calculate the moving average
  current_sum = 0;
  voltage_sum = 0;
  for (int i = 0; i < windowSize; i++) {
    current_sum += current_values[i];
    voltage_sum += voltage_values[i];
    /*Diagnostics
    Serial.print(current_values[i]);
    Serial.println(); */
  }
  
//solve negative current
if (current_sum <0){
  current_sum = 0;
}

//Calculate the 5pma output 
current_measurement_output = current_sum/windowSize;
voltage_measurement_output = voltage_sum/windowSize;
power_measurement_output = current_measurement_output*voltage_measurement_output;


//print values
Serial.print("current [mA] = ");
Serial.println(current_measurement_output);
Serial.println();
Serial.print("voltage [V] = ");
Serial.println(voltage_measurement_output);
Serial.println();
Serial.println();

//----------------- actions ----------------------------------

if (power_measurement_output > safety_factor * critical_power) {
    operational_state = HIGH;
    //Serial.println("Systems Operational");
    digitalWrite(OK_PIN, HIGH);
    exceed = 0;
  }
  else {
    operational_state = LOW;
    exceed++;
    digitalWrite(OK_PIN, LOW);
    digitalWrite(WARNING_PIN, HIGH);
    delay(alarm_on_time);
    digitalWrite(WARNING_PIN, LOW);
    delay(alarm_off_time);
    if (exceed > exceed_threshold) {
      //alarm procedure
      //Serial.println("System Disruption!");
      user_message = switchover_BES_to_RES_message;
      send_push_notification = HIGH;
      for (j = 1; j <= alarm_rings; j++) {
        digitalWrite(ALARM_PIN, HIGH);
        delay(alarm_on_time);
        digitalWrite(ALARM_PIN, LOW);
        delay(alarm_off_time);
      }
    }
    Serial.println();
    Serial.println();

  }

//-----------------closing loop-------------------------------

delay(100);
  
}





/*
  Since CriticalVoltage is READ_WRITE variable, onCriticalVoltageChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCriticalVoltageChange()  {
  // Add your code here to act upon CriticalVoltage change
}

/*
  Since OperationalState is READ_WRITE variable, onOperationalStateChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onOperationalStateChange()  {
  // Add your code here to act upon OperationalState change
}

/*
  Since SendPushNotification is READ_WRITE variable, onSendPushNotificationChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onSendPushNotificationChange()  {
  // Add your code here to act upon SendPushNotification change
}

/*
  Since UserMessage is READ_WRITE variable, onUserMessageChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onUserMessageChange()  {
  // Add your code here to act upon UserMessage change
}

/*
  Since AlertsOn is READ_WRITE variable, onAlertsOnChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onAlertsOnChange()  {
  // Add your code here to act upon AlertsOn change
}

/*
  Since PowerMeasurementOutput is READ_WRITE variable, onPowerMeasurementOutputChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPowerMeasurementOutputChange()  {
  // Add your code here to act upon PowerMeasurementOutput change
}

/*
  Since CriticalPower is READ_WRITE variable, onCriticalPowerChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCriticalPowerChange()  {
  // Add your code here to act upon CriticalPower change
}